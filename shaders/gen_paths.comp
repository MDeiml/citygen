#version 430

layout (local_size_x = 7, local_size_y = 13, local_size_z = 11) in;

const uvec3 CELL_SIZE = uvec3(8, 4, 8);
const uvec3 OUTPUT_SIZE = uvec3(128, 128, 128);
const uvec3 OUTPUT_SIZE_GROUP = gl_WorkGroupSize - uvec3(2);
const uvec3 OUTPUT_OFFSET_GROUP = uvec3(0, 1, 0);
const uvec3 NUM_GROUPS = OUTPUT_SIZE / CELL_SIZE;

shared uvec3 path_offset[gl_WorkGroupSize.x][gl_WorkGroupSize.y][gl_WorkGroupSize.z];
shared uint align[gl_WorkGroupSize.x][gl_WorkGroupSize.y][gl_WorkGroupSize.z];

layout (std430, binding = 0) restrict buffer voxel_buffer {
    uvec2 voxels[];
};

layout (binding = 0) uniform atomic_uint voxel_counter;

uvec3 get_path_offset(uvec3 v) {
    return path_offset[v.x][v.y][v.z];
}

uint get_align(uvec3 v) {
    return align[v.x][v.y][v.z];
}

float rand(vec2 v) {
    return fract(sin(dot(v, vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    // initialize random number generator with position and seed
    float r = rand(vec2(
        dot(
            vec3(gl_LocalInvocationID + OUTPUT_SIZE_GROUP * gl_WorkGroupID),
            vec3(1.0, NUM_GROUPS.x, NUM_GROUPS.x * NUM_GROUPS.y)
        ),
        0.2
    ));
    // generate random path offset
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].x = uint(rand(vec2(r, 0.0)) * float(CELL_SIZE.x * CELL_SIZE.y * CELL_SIZE.z));
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].z = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 5, 3);
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].y = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 3, 2);
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].x = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 0, 3);

    // generate random align
    // layout:
    // 1 bit [ALIGN X]
    // 1 bit [ALIGN Z]
    // 2 bits [ALIGN_Y X]
    // 2 bits [ALIGN_Y Z]
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = uint(step(0.33, rand(vec2(r, 1.0))));
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(step(0.33, rand(vec2(r, 2.0)))) << 1;
    if (get_align(gl_LocalInvocationID) == 0) {
        align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = uint(rand(vec2(r, 3.0)) * 2.0 + 1.0);
    }
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(rand(vec2(r, 4.0)) * 3.0) << 2;
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(rand(vec2(r, 5.0)) * 3.0) << 4;
    uvec2 temp = uvec2(get_align(gl_LocalInvocationID), 0);

    /*
    barrier();
    if (gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1 && gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        int a = int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2));
        // if path in +x is not straight
        if (bitfieldExtract(get_align(gl_LocalInvocationID + ivec3(1, a - 1, 0)), 2, 2) != 1) {
            // don't create up or down path
            temp.x &= ~(2u << 2);
            temp.x |= 1u << 2;
        }
    }
    if (gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1 && gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        int a = int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2));
        // if path in +z is not straight
        if (bitfieldExtract(get_align(gl_LocalInvocationID + ivec3(0, a - 1, 1)), 4, 2) != 1) {
            // don't create up or down path
            temp.x &= ~(2u << 4);
            temp.x |= 1u << 4;
        }
    }
    */
    barrier();
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = temp.x;
    temp = get_path_offset(gl_LocalInvocationID).xz;

    // align straight
    barrier();
    if ((get_align(gl_LocalInvocationID) & 1u) != 0 && gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1) {
        temp.y = get_path_offset(gl_LocalInvocationID + uvec3(1, 0, 0)).z;
    }
    if ((get_align(gl_LocalInvocationID) & 2u) != 0 && gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1) {
        temp.x = get_path_offset(gl_LocalInvocationID + uvec3(0, 0, 1)).x;
    }
    barrier();
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].xz = temp;

    // align straight/up/down
    barrier();
    if ((get_align(gl_LocalInvocationID) & 1u) != 0 && gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1 &&
        gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        temp.y = get_path_offset(gl_LocalInvocationID + ivec3(1, int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2)) - 1, 0)).z;
    }
    if ((get_align(gl_LocalInvocationID) & 2u) != 0 && gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1 &&
        gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        temp.x = get_path_offset(gl_LocalInvocationID + ivec3(0, int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2)) - 1, 1)).x;
    }
    barrier();
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].xz = temp;

    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] += (gl_LocalInvocationID + OUTPUT_SIZE_GROUP * gl_WorkGroupID) * CELL_SIZE;
    barrier();

    if (all(lessThan(gl_LocalInvocationID, OUTPUT_SIZE_GROUP + OUTPUT_OFFSET_GROUP)) &&
        all(greaterThanEqual(gl_LocalInvocationID, OUTPUT_OFFSET_GROUP))) {
        // write x path
        int dy = int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2)) - 1;
        if (get_path_offset(gl_LocalInvocationID + ivec3(1, dy, 0)).z == get_path_offset(gl_LocalInvocationID).z) {
            align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= 1u << 6;
            ivec2 dist = ivec2(get_path_offset(gl_LocalInvocationID + uvec3(1, dy, 0)).xy) - ivec2(get_path_offset(gl_LocalInvocationID).xy);
            if (abs(dist.y) <= dist.x) {
                for (int i = 0; i < dist.x; i++) {
                    uvec3 offset1 = uvec3(ivec3(get_path_offset(gl_LocalInvocationID)) + ivec3(i, i * dist.y / dist.x, 0)) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
                    if (all(lessThan(offset1, OUTPUT_SIZE))) {
                        offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
                        uint index = atomicCounterIncrement(voxel_counter);
                        voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 0xff0000);
                    }
                }
            }
        }
        // write z path
        dy = int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2)) - 1;
        if (get_path_offset(gl_LocalInvocationID + uvec3(0, dy, 1)).x == get_path_offset(gl_LocalInvocationID).x) {
            align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= 2u << 6;
            ivec2 dist = ivec2(get_path_offset(gl_LocalInvocationID + ivec3(0, dy, 1)).zy) - ivec2(get_path_offset(gl_LocalInvocationID).zy);
            if (abs(dist.y) <= dist.x) {
                for (int i = 0; i < dist.x; i++) {
                    uvec3 offset1 = uvec3(ivec3(get_path_offset(gl_LocalInvocationID)) + ivec3(0, i * dist.y / dist.x, i)) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
                    if (all(lessThan(offset1, OUTPUT_SIZE))) {
                        offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
                        uint index = atomicCounterIncrement(voxel_counter);
                        voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 0xff0000);
                    }
                }
            }
        }

        if ((get_align(gl_LocalInvocationID) & (3 << 6)) != 0) {
            uvec3 offset1 = get_path_offset(gl_LocalInvocationID) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
            if (all(lessThan(offset1, OUTPUT_SIZE))) {
                offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
                uint index = atomicCounterIncrement(voxel_counter);
                voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 0xffff00);
            }
        }
    }
}

