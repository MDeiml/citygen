#version 430

const uvec3 CELL_SIZE = uvec3(8, 4, 8);
const uvec3 OUTPUT_SIZE = uvec3(128, 128, 128);
const uvec3 OUTPUT_SIZE_GROUP = uvec3(8, 8, 8);
const uvec3 OUTPUT_OFFSET_GROUP = uvec3(0, 1, 0);
const uvec3 NUM_GROUPS = OUTPUT_SIZE / CELL_SIZE;

layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in;

shared uvec3 path_offset[10][10][10];
shared uint align [10][10][10];

layout (std430, binding = 0) restrict buffer voxel_buffer {
    uvec2 voxels[];
};

// Can't use atomic counter because glium doesn't support it
// Can't put counter in voxel_buffer because glium doesn't support it
layout (binding = 0) uniform atomic_uint voxel_counter;

uvec3 get_path_offset(uvec3 v) {
    return path_offset[v.x][v.y][v.z];
}

uint get_align(uvec3 v) {
    return align[v.x][v.y][v.z];
}

float rand(vec2 v) {
    return fract(sin(dot(v, vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    float r = rand(vec2(
        dot(
            vec3(gl_LocalInvocationID + 8 * gl_WorkGroupID),
            vec3(1.0, NUM_GROUPS.x, NUM_GROUPS.x * NUM_GROUPS.y)
        ),
        0.2
    ));
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].x = uint(rand(vec2(r, 0.0)) * float(CELL_SIZE.x * CELL_SIZE.y * CELL_SIZE.z));
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].z = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 5, 3);
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].y = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 3, 2);
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].x = bitfieldExtract(get_path_offset(gl_LocalInvocationID).x, 0, 3);

    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = uint(step(0.33, rand(vec2(r, 1.0))));
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(step(0.33, rand(vec2(r, 2.0)))) << 1;
    if (get_align(gl_LocalInvocationID) == 0) {
        align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = uint(rand(vec2(r, 3.0)) * 2.0 + 1.0);
    }
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(rand(vec2(r, 2.0)) * 3.0) << 2;
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= uint(rand(vec2(r, 2.0)) * 4.0) << 4;
    uvec2 temp = uvec2(get_align(gl_LocalInvocationID), 0);

    barrier();
    if (gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1 && gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        int a = int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2));
        if (bitfieldExtract(get_align(gl_LocalInvocationID + ivec3(1, a - 1, 0)), 2, 2) != 1) {
            temp.x &= ~(3u << 2);
            temp.x |= 1u << 2;
        }
    }
    if (gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1 && gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        int a = int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2));
        if (bitfieldExtract(get_align(gl_LocalInvocationID + ivec3(0, a - 1, 1)), 4, 2) != 1) {
            temp.x &= ~(3u << 4);
            temp.x |= 1u << 4;
        }
    }
    barrier();
    align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] = temp.x;
    temp = get_path_offset(gl_LocalInvocationID).xz;

    barrier();
    if ((get_align(gl_LocalInvocationID) & 1u) != 0 && gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1) {
        temp.y = get_path_offset(gl_LocalInvocationID + uvec3(1, 0, 0)).z;
    }
    if ((get_align(gl_LocalInvocationID) & 2u) != 0 && gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1) {
        temp.x = get_path_offset(gl_LocalInvocationID + uvec3(0, 0, 1)).x;
    }
    barrier();
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].xz = temp;

    barrier();
    if ((get_align(gl_LocalInvocationID) & 1u) != 0 && gl_LocalInvocationID.x < gl_WorkGroupSize.x - 1 &&
        gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        temp.y = get_path_offset(gl_LocalInvocationID + ivec3(1, int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2)) - 1, 0)).z;
    }
    if ((get_align(gl_LocalInvocationID) & 2u) != 0 && gl_LocalInvocationID.z < gl_WorkGroupSize.z - 1 &&
        gl_LocalInvocationID.y >= 1 && gl_LocalInvocationID.y < gl_WorkGroupSize.y - 1) {
        temp.x = get_path_offset(gl_LocalInvocationID + ivec3(0, int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2)) - 1, 1)).x;
    }
    barrier();
    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z].xz = temp;

    path_offset[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] += (gl_LocalInvocationID + 8 * gl_WorkGroupID) * CELL_SIZE;
    barrier();

    if (all(lessThan(gl_LocalInvocationID, OUTPUT_SIZE_GROUP + OUTPUT_OFFSET_GROUP)) &&
        all(greaterThanEqual(gl_LocalInvocationID, OUTPUT_OFFSET_GROUP))) {
        int dy = int(bitfieldExtract(get_align(gl_LocalInvocationID), 2, 2)) - 1;
        if (get_path_offset(gl_LocalInvocationID + ivec3(1, dy, 0)).z == get_path_offset(gl_LocalInvocationID).z) {
            align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= 1u << 6;
            ivec2 dist = ivec2(get_path_offset(gl_LocalInvocationID + uvec3(1, dy, 0)).xy) - ivec2(get_path_offset(gl_LocalInvocationID).xy);
            if (abs(dist.y) <= dist.x) {
                for (int i = 0; i < dist.x; i++) {
                    uvec3 offset1 = uvec3(ivec3(get_path_offset(gl_LocalInvocationID)) + ivec3(i, i * dist.y / dist.x, 0)) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
                    offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
                    uint index = atomicCounterIncrement(voxel_counter);
                    voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 9);
                }
            }
        }
        dy = int(bitfieldExtract(get_align(gl_LocalInvocationID), 4, 2)) - 1;
        if (get_path_offset(gl_LocalInvocationID + uvec3(0, dy, 1)).x == get_path_offset(gl_LocalInvocationID).x) {
            align[gl_LocalInvocationID.x][gl_LocalInvocationID.y][gl_LocalInvocationID.z] |= 2u << 6;
            ivec2 dist = ivec2(get_path_offset(gl_LocalInvocationID + ivec3(0, dy, 1)).zy) - ivec2(get_path_offset(gl_LocalInvocationID).zy);
            if (abs(dist.y) <= dist.x) {
                for (int i = 0; i < dist.x; i++) {
                    uvec3 offset1 = uvec3(ivec3(get_path_offset(gl_LocalInvocationID)) + ivec3(0, i * dist.y / dist.x, i)) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
                    offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
                    uint index = atomicCounterIncrement(voxel_counter);
                    voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 9);
                }
            }
        }

        if ((get_align(gl_LocalInvocationID) & (3 << 6)) != 0) {
            uint color = 0xff0000;
            if ((get_align(gl_LocalInvocationID) & (1u << 6)) != 0) {
                color |= 0xff00u;
            }
            if ((get_align(gl_LocalInvocationID) & (2u << 6)) != 0) {
                color |= 0xffu;
            }
            uvec3 offset1 = get_path_offset(gl_LocalInvocationID) - OUTPUT_OFFSET_GROUP * CELL_SIZE;
            offset1.yz *= uvec2(OUTPUT_SIZE.x, OUTPUT_SIZE.x * OUTPUT_SIZE.y);
            uint index = atomicCounterIncrement(voxel_counter);
            voxels[index] = uvec2(offset1.x + offset1.y + offset1.z, 9);
        }
    }
}

